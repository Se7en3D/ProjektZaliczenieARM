/**
  ******************************************************************************
  * @file    dacConverter.c
  * @author  Daniel Dunak
  * @brief   Plik zródłowy odpowiedzialny za kontrolę nad przetwornikiem konwertującym bity na przebieg sinusoidalny
  *
  ******************************************************************************
  */
#include "stm32f4xx_hal.h"
#include <stdio.h>
#include "dacConverter.h"
#include "stateMachine.h"
#include "uartCom.h"

/**
 * @brief dacSin4700[] tablica zawerająca próbki sygnału sinusoidalnego dla czestotliwości 4700Hz
 */
volatile static const uint32_t dacSin4700[]={
		2048,
		2176,
		2303,
		2427,
		2548,
		2665,
		2776,
		2881,
		2979,
		3068,
		3149,
		3220,
		3280,
		3330,
		3368,
		3395,
		3410,
		3413,
		3404,
		3383,
		3350,
		3306,
		3251,
		3185,
		3110,
		3025,
		2931,
		2830,
		2721,
		2607,
		2488,
		2365,
		2239,
		2112,
		1984,
		1857,
		1731,
		1608,
		1489,
		1375,
		1266,
		1165,
		1071,
		986,
		911,
		845,
		790,
		746,
		713,
		692,
		683,
		686,
		701,
		728,
		766,
		816,
		876,
		947,
		1028,
		1117,
		1215,
		1320,
		1431,
		1548,
		1669,
		1793,
		1920,
		2048,
		2176,
		2303,
		2427,
		2548,
		2665,
		2776,
		2881,
		2979,
		3068,
		3149,
		3220,
		3280,
		3330,
		3368,
		3395,
		3410,
		3413,
		3404,
		3383,
		3350,
		3306,
		3251,
		3185,
		3110,
		3025,
		2931,
		2830,
		2721,
		2607,
		2488,
		2365,
		2239,
		2112,
		1984,
		1857,
		1731,
		1608,
		1489,
		1375,
		1266,
		1165,
		1071,
		986,
		911,
		845,
		790,
		746,
		713,
		692,
		683,
		686,
		701,
		728,
		766,
		816,
		876,
		947,
		1028,
		1117,
		1215,
		1320,
		1431,
		1548,
		1669,
		1793,
		2048,
};
/**
 * @brief dacSin6700[] tablica zawerająca próbki sygnału sinusoidalnego dla czestotliwości 6700hz
 */
volatile static const uint32_t dacSin6700[]={
		2048,
		2230,
		2409,
		2581,
		2744,
		2894,
		3029,
		3147,
		3245,
		3322,
		3376,
		3406,
		3413,
		3394,
		3352,
		3286,
		3199,
		3091,
		2964,
		2821,
		2664,
		2496,
		2320,
		2139,
		1957,
		1776,
		1600,
		1432,
		1275,
		1132,
		1005,
		897,
		810,
		744,
		702,
		683,
		690,
		720,
		774,
		851,
		949,
		1067,
		1202,
		1352,
		1515,
		1687,
		1866,
		2048,
		2230,
		2409,
		2581,
		2744,
		2894,
		3029,
		3147,
		3245,
		3322,
		3376,
		3406,
		3413,
		3394,
		3352,
		3286,
		3199,
		3091,
		2964,
		2821,
		2664,
		2496,
		2320,
		2139,
		1957,
		1776,
		1600,
		1432,
		1275,
		1132,
		1005,
		897,
		810,
		744,
		702,
		683,
		690,
		720,
		774,
		851,
		949,
		1067,
		1202,
		1352,
		1515,
		1687,
		1866,
		2048,
		2230,
		2409,
		2581,
		2744,
		2894,
		3029,
		3147,
		3245,
		3322,
		3376,
		3406,
		3413,
		3394,
		3352,
		3286,
		3199,
		3091,
		2964,
		2821,
		2664,
		2496,
		2320,
		2139,
		1957,
		1776,
		1600,
		1432,
		1275,
		1132,
		1005,
		897,
		810,
		744,
		702,
		683,
		690,
		720,
		774,
		2048,
};

/**
  * @brief	Inicjaliazcja struktury dacBaseStruct do wartości domyślnych
  * @param	hdac wskaźnik na strukturę DAC_HandleTypeDef
  * @retval None
  */
void dacConverterInit(DAC_HandleTypeDef *hdac){
	dacBaseStruct.hdac=hdac;
	dacBaseStruct.bitSendNumber=0;
	dacBaseStruct.sizeWaveF0=sizeof(dacSin4700)/sizeof(uint32_t);
	dacBaseStruct.sizeWaveF1=sizeof(dacSin6700)/sizeof(uint32_t);
}

/**
  * @brief	Przejście do konwersji kolejnego bitu
  * @retval None
  */
void dacNextBitConvert(){
	if(dacBaseStruct.status==DACCONVERTER_BUSY){
		if(dacBaseStruct.bitSendNumber>DACCINVERTER_MAX_BIT_TO_SEND){
			dacBaseStruct.status=DACCONVERTER_IDLE;
			if(uartComGetSizeDataInBuffor(&uartComBufforToCommunicationRx)==0){
				stateMachineChangeToReceving();
			}
			dacBaseStruct.bitSendNumber=0;
			return;
		}
		if((dacBaseStruct.dataToSend&(1<<dacBaseStruct.bitSendNumber))==0){
			HAL_DAC_Start_DMA(dacBaseStruct.hdac, DAC1_CHANNEL_1,(uint32_t*) dacSin4700, dacBaseStruct.sizeWaveF0, DAC_ALIGN_12B_R);
		}else{
			HAL_DAC_Start_DMA(dacBaseStruct.hdac, DAC1_CHANNEL_1,(uint32_t*) dacSin6700, dacBaseStruct.sizeWaveF1, DAC_ALIGN_12B_R);
		}

		dacBaseStruct.bitSendNumber++;
	}

}
/**
  * @brief	Przejście do konwersji kolejnego bitu
  * @param	data wartość 8 bitowa danych do wysłania
  * @retval None
  */
void dacConverterSetNewDataToSend(uint8_t data){
	if(dacBaseStruct.status==DACCONVERTER_IDLE){
		dacBaseStruct.dataToSend=data;
		if(dacBaseStruct.timeBreak>=DACCONVERTER_TIME_BREAK){
			dacBaseStruct.numberOfContinousConversions=0;
		}else{
			dacBaseStruct.numberOfContinousConversions++;
			if(dacBaseStruct.numberOfContinousConversions>=DACCONVERTER_MAX_BYTE_TO_SEND_WITHOUT_BREAK){
				dacBaseStruct.numberOfContinousConversions=0;
				dacBaseStruct.timeBreak=0;
				dacBaseStruct.status=DACCONVERTER_BREAK;
				return;
			}
		}
		dacBaseStruct.status=DACCONVERTER_BUSY;
		if(dacBaseStruct.bitSendNumber!=0){
			dacBaseStruct.bitSendNumber=0;
		}
		dacNextBitConvert();
	}
}

/**
  * @brief	Zarzadzanie zmienną timeBreak
  * @retval None
  */
void dacAddTimeBraek(){
	switch(dacBaseStruct.status){
		case DACCONVERTER_IDLE:
			dacBaseStruct.timeBreak++;
			break;
		case DACCONVERTER_BUSY:
			dacBaseStruct.timeBreak=0;
			break;
		case DACCONVERTER_BREAK:
			if(dacBaseStruct.timeBreak>=DACCONVERTER_TIME_BREAK){
				dacBaseStruct.timeBreak=0;
				dacBaseStruct.status=DACCONVERTER_BUSY;
				dacNextBitConvert();
			}else{
				dacBaseStruct.timeBreak++;
			}
			break;
	}
}
